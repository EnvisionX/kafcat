#!/usr/bin/env python

"""
Read Kafka topic contents and output it to the stdout.
"""

import argparse
import os.path
import sys
import time

import kafka
import kafka.common


def parse_cmd_args():
    """
    Parse command line arguments and options.
    Return object with parsed data.

    :rtype: object
    """
    parser = argparse.ArgumentParser(
        description='Read Kafka topic contents and output it'
        ' to the stdout.')
    parser.add_argument(
        '--host', default='localhost',
        help='Kafka broker hostname.')
    parser.add_argument(
        '--port', type=port_number, default='9092',
        help='Kafka broker hostname.')
    parser.add_argument(
        '--id', default='kafcat',
        help='Kafka client ID.')
    parser.add_argument(
        '--maxtime', type=int, metavar='SECONDS',
        help='Maximum time to work. If defined, kafcat will'
        ' exit after the given amount of time even if there'
        ' is data to read in the Kafka.')
    parser.add_argument(
        '--maxmsgs', type=int, metavar='COUNT',
        help='Maximum messages to read. If defined, kafcat will'
        ' exit after Count messages will be read even if'
        ' there is data to read in the Kafka.')
    parser.add_argument(
        '-b', '--begin', action='store_true',
        help='Extract from the beginning.')
    parser.add_argument(
        '-f', '--follow', action='store_true',
        help='Output appended data as the topic grows.')
    parser.add_argument(
        'topic_name',
        help='Kafka topic to read.')
    return parser.parse_args()


def port_number(string):
    """
    Convert string to TCP port number.

    :param string: text representation of TCP port number.
    :type string: string

    :rtype: integer
    """
    port_number = int(string)
    if 0 < port_number <= 0xffff:
        return port_number
    raise ValueError


if __name__ == '__main__':
    cmd_opts = parse_cmd_args()
    consumer = None
    try:
        # connect to Kafka
        client = kafka.KafkaClient('%s:%d' % (cmd_opts.host, cmd_opts.port))
        # Create consumer object
        consumer = kafka.SimpleConsumer(
            client, cmd_opts.id, cmd_opts.topic_name, iter_timeout = 0.5)
        if cmd_opts.begin:
            # seek very first message
            consumer.seek(0, 0)
            consumer.commit()
        # start consuming
        total_messages_read = 0
        started = time.time()
        maxtime = cmd_opts.maxtime
        maxmsgs = cmd_opts.maxmsgs
        while True:
            if maxtime is not None and time.time() >= started + maxtime:
                break
            try:
                for message in consumer:
                    total_messages_read += 1
                    sys.stdout.write(message.message.value + '\n')
                    if maxtime is not None and \
                       time.time() >= started + maxtime:
                        break
                    if maxmsgs is not None and \
                       total_messages_read >= maxmsgs:
                        break
            except kafka.common.OffsetOutOfRangeError:
                if total_messages_read == 0:
                    # This kind of error arises when we try to fetch
                    # logs which already was rolled out from the storage.
                    # On the server side Kafka emits message like:
                    #     "kafka.common.OffsetOutOfRangeException: Request
                    #     for offset 0 but we only have log segments in
                    #     the range 39943 to 11471647."
                    # This issue is described in
                    #  https://github.com/mumrah/kafka-python/issues/72
                    # The workaround is to make consumer.seek(0,0).
                    # Obviously, the issue is not reproduced when kafcat
                    # is invoked with '-b' command line option.
                    consumer.seek(0, 0)
                    consumer.commit()
                    # try to consume again:
                    for message in consumer:
                        total_messages_read += 1
                        sys.stdout.write(message.message.value + '\n')
                        if maxtime is not None and \
                           time.time() >= started + maxtime:
                            break
                        if maxmsgs is not None and \
                           total_messages_read >= maxmsgs:
                            break
            if not cmd_opts.follow:
                break
        # save current position for the future use
        consumer.commit()
    except KeyboardInterrupt:
        if consumer is not None:
            # save current position for the future use
            consumer.commit()
        sys.exit(130)
